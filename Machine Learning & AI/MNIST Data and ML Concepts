{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "TuDw9-a-KCPL"
   },
   "source": [
    "# Preparing the Data\n",
    "\n",
    "Keras has code that will load a basic version of your data into lists in Python, but they aren't yet formatted in a way that your neural network will be able to use.\n",
    "\n",
    "Reshaping and processing data into a format that the neural network can consume is a key step in any machine learning problem.\n",
    "\n",
    "In this lesson, you will learn how to prepare the MNIST dataset so that it can be put into a neural network. \n",
    "\n",
    "1. Run the cell below to import relevant libraries and add helper functions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "id": "_evbU9zqK-6n"
   },
   
   "source": [
    "import tensorflow as tf\n",
    "from tensorflow import keras\n",
    "from tensorflow.keras.datasets import mnist\n",
    "from tensorflow.keras import backend as K\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "\n",
    "# helper functions\n",
    "def show_min_max(array, i):\n",
    "  random_image = array[i]\n",
    "  print(random_image.min(), random_image.max())\n",
    "\n",
    "def plot_image(array, i, labels):\n",
    "  plt.imshow(np.squeeze(array[i]))\n",
    "  plt.title(\" Digit \" + str(labels[i]))\n",
    "  plt.xticks([])\n",
    "  plt.yticks([])\n",
    "  plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "lrzNGVxNLFvv"
   },
   "source": [
    "In the MNIST Data set, there are 60,000 training images and 10,000 test images. Each image is 28 x 28 pixels. There are 10 possible output classes, and there is one color channel, meaning that each image is stored as a 28 x 28 grid of numbers between 0 and 255. \n",
    "\n",
    "2. Use this information to set these variables to the correct values. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "id": "rrWWILG1LSW3"
   },
   "outputs": [],
   "source": [
    "img_rows = 28\n",
    "img_cols = 28\n",
    "num_classes =  10"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "KN4FECP3LaBn"
   },
   "source": [
    "Now you can load the data into your program. You will also load a backup version of the data, so you have something to compare that hasn't been affected by the network. \n",
    "\n",
    "3. Run the cell below to get the training and testing dataset and labels. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "id": "LqzBE-PrLhhH"
   },
   "outputs": [],
   "source": [
    "(train_images, train_labels), (test_images, test_labels) = mnist.load_data() \n",
    "(train_images_backup, train_labels_backup), (test_images_backup, test_labels_backup) = mnist.load_data() \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "xjbHl8_LLp2P"
   },
   "source": [
    "4. Add code in the cell below to print out the shape of the train and test datasets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "id": "pPxvvtenLvFX"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(60000, 28, 28)\n",
      "(10000, 28, 28)\n"
     ]
    }
   ],
   "source": [
    "# Add code here to see the shape of the data\n",
    "print(train_images.shape)\n",
    "print(test_images.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "0ovBXpdgLx0e"
   },
   "source": [
    "# Sorting Through the Data\n",
    "\n",
    "## Data Formatting\n",
    "\n",
    "Data can be formatted in many different ways, and a Machine Learning expert will need to handle this in their code. Since the MNIST data is already so well prepared for machine learning applications there isn't a lot of reshaping or preparation that needs to go into it.\n",
    "\n",
    "However, in other situations, you might come across data that needs more hefty reshaping and re-organizing. This is an important skill to develop, and as you expand your machine learning abilities you will learn more about how to deal with different types of data. \n",
    "\n",
    "For now, you will just reshape the data so that it is an appropriate size for your network. \n",
    "\n",
    "1. Add a print statement to the cell below to see the new shape of the data. \n",
    "2. Run the cell below to reshape the data from a long list of pixels to a 28x28 grid. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "id": "pJbMzq2UL73W"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(60000, 28, 28, 1)\n",
      "(10000, 28, 28, 1)\n"
     ]
    }
   ],
   "source": [
    "train_images = train_images.reshape(train_images.shape[0], img_rows, img_cols, 1)\n",
    "test_images = test_images.reshape(test_images.shape[0], img_rows, img_cols, 1)\n",
    "# Add print statements to see the new shape.\n",
    "\n",
    "print(train_images.shape)\n",
    "print(test_images.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "3XN0YAaXMfM1"
   },
   "source": [
    "3. In the cell below add the value of the input shape variable."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "id": "w8UdTlaBMwq-"
   },
   "outputs": [],
   "source": [
    "input_shape = (img_rows, img_cols, 1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "DQEFe15jMzhM"
   },
   "source": [
    "## Data Cleaning\n",
    "\n",
    "Now that the data is in the right shape, we can do some simple data cleaning.  Follow these steps to learn a bit about what the data currently looks like.\n",
    "\n",
    "\n",
    "1. Run the cell below to see what an image looks like"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "id": "_9HOgEBZM_a8"
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAOsAAAD7CAYAAACL3GNOAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/YYfK9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAIXklEQVR4nO3df6zVdR3H8df73huXi1elK1CTyygMIhfadMaS1mo0p7hm02ZLXT82aObcWK1ytpxba6U23TJbVmvhMqf2h2RT+sPbaJUIRROLoKYSYisSrnaHCfcH7/6A2k3P9yP3nMM953XP87GxAe/z/Z7P3XjyuezDOScyUwDaX1erFwDgxBArYIJYARPECpggVsAEsQImiNVcRGyKiE80+7FoP8E5a/uKiJT0b0kp6YikJyV9LzMfaMK9PylpbWa+t/CYDZKukjQ66bdPz8yJRp8fU8fO2v7Ozcx+SW+XtEHSXRFx8zQ+/22Z2T/pB6G2CLGayMwDmfkjSZ+RdGNEnCFJEbE5ItYe/3l3RNweEQciYk9EXB8RGRE9kx8bEe+QdLek90TEoYh4qUVfFqaAWP38VFKPpHfXmK2TdImkd0k6T9KHa90gM3dJulbSluO75dzC810XEcMRsT0irmhg3WgQsZrJzDFJByQN1BhfKembmfl8Zr4o6ZYGn+5OSUslLZB0k6QNEbGqwXuiTsRqJiLeIGm+pOEa4zMl7Zv06301HnPCMvP3mXkwM8cz81FJP5Z0eSP3RP2I1c9lksYlbasx+7ukwUm/XlS4Tz3HACkp6rgOTUCsJiJiICKulvRtSbdm5sEaD3tQ0vqIWBgRcyXdULjlfkmDETGr8JwfiYj+iOiKiIskXSPp4fq/CjSip9ULwOvacfy8dVTSDkmfzcz7Kh77fUnLJD0laUTH/s35fkm1jlt+IWmnpH9ExNHMnFfjMesl/UDHdtM9ktZl5ub6vxQ0gv8UMYNFxCWS7s7Mxa1eCxrHt8EzSET0RcSaiOiJiIWSbpb0UKvXheZgZ51BImKOpF9KWi7pFUmPSFqfmSMtXRiaglgBE3wbDJggVsDElI5uZkVvztYpJ2stQMc7rJc1mkdq/seTKcU6W6doZaxuzqoAvMbWHKqc8W0wYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsBET6sXgAZ1dRfHPW+aX5yPnvXm4vzpq2dNeUn/9atL7yjOB3v6i/Nnxg5Vzi77zheL1y685fHi3BE7K2CCWAETxAqYIFbABLECJogVMMHRTRvonl99vPK3q5YWr80PvFicb7/g3rrW1Ax/GSsfKz02sqA4f/rwisrZok3lr/toceqJnRUwQayACWIFTBArYIJYARPECpggVsAE56xtYPdNSypnf77iW9O4ktfaNTZWObvn4IXFa7d/+fzivHfTb+ta0zG7GrjWEzsrYIJYARPECpggVsAEsQImiBUwQayACc5Zp8Ge+88pzp9YVXrLztnFa/919HBx/r7vfqE4P+NPE8V53/4jlbP4zZPFa3vVyDkqXo2dFTBBrIAJYgVMECtgglgBE8QKmCBWwATnrNPg42dvK87f2FU+Sy354+ipxfmir868jz7sVOysgAliBUwQK2CCWAETxAqYIFbABLECJjhnnQb37r6gOL9h1c667732oU8X52fpibrvjfbCzgqYIFbABLECJogVMEGsgAliBUxwdDMN+jaXX8amVdWjI1n9kYuSNDhUfitRzBzsrIAJYgVMECtgglgBE8QKmCBWwASxAiY4Z21zh7N8jtq7iY9V7BTsrIAJYgVMECtgglgBE8QKmCBWwASxAiaIFTBBrIAJYgVMECtgglgBE8QKmCBWwASxAiaIFTBBrIAJYgVMECtgglgBE8QKmCBWwASxAiZ43+BpcObPnivOt3y+u3J27qzy36dd5ywvzo8+tbs4hw92VsAEsQImiBUwQayACWIFTBArYIKjm2kwvu/54vyliTmVszlR/sjHGzfeX5zveGVxcf567nxkTeVs6e3PFK+d2P/Php4b/4+dFTBBrIAJYgVMECtgglgBE8QKmCBWwERk5gk/+LQYyJWx+iQupzMd+vmSytnmFT+ZxpVMzaf2lv8sPHfbsuK8b+O2Zi5nRtiaQxrJ4ag1Y2cFTBArYIJYARPECpggVsAEsQImiBUwwetZ20D/mr2Vs3d+5fritQM7y+fkL5xX88juf9Zd/Fhx/rmB6rcy/eHioeK1yy5dWp5vLI7xKuysgAliBUwQK2CCWAETxAqYIFbABLECJng9a4frWfKW4vyjj/66cvaxU/cXr/3agRXF+Zbzq98vWZJyfLw4n4l4PSswAxArYIJYARPECpggVsAEsQImeIlchxt/9q/F+a33XFk5u/i6bxSv/dK8PxTnH+q+sDhXBx7dlLCzAiaIFTBBrIAJYgVMECtgglgBE8QKmOCcFUWDX3+8cvbANWcXr7127rPNXk5HY2cFTBArYIJYARPECpggVsAEsQImiBUwwTkrirrf9tbK2ZLe6o+DRPOxswImiBUwQayACWIFTBArYIJYARPECpjgnBVFu9cvqJxd1Pdy8do7hpeXbz4xUc+SOhY7K2CCWAETxAqYIFbABLECJogVMEGsgAnOWVE073eFv88vL1/74F0fLN97fEsdK+pc7KyACWIFTBArYIJYARPECpggVsBEZOYJP/i0GMiVsfokLgfobFtzSCM5HLVm7KyACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImpvR61oh4QdLek7ccoOMtzsz5tQZTihVA6/BtMGCCWAETxAqYIFbABLECJogVMEGsgAliBUwQK2DiP4IcdWCMsGcwAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plot_image(train_images, 100, train_labels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "kF47IBF0NFWk"
   },
   "source": [
    "Now let's see what the numbers representing the pixels inside that image look like. \n",
    "\n",
    "\n",
    "2. Run the next cell to see what the computer is currently looking at."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "id": "ajiuP_SVNPUU"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   2  18  46 136 136 244 255 241 103   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0  15  94 163 253 253 253 253 238 218 204  35   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0 131 253 253 253 253 237 200  57   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0 155 246 253 247 108  65  45   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0 207 253 253 230   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0 157 253 253 125   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0  89 253 250  57   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0  89 253 247   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0  89 253 247   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0  89 253 247   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0  21 231 249  34   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0 225 253 231 213 213 123  16   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0 172 253 253 253 253 253 190  63   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   2 116  72 124 209 253 253 141   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0  25 219 253 206   3   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 104 246 253   5   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 213 253   5   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0  26 226 253   5   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 132 253 209   3   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0  78 253  86   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n",
      "  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n"
     ]
    }
   ],
   "source": [
    "out = \"\"\n",
    "for i in range(28):\n",
    "  for j in range(28):\n",
    "    f = int(train_images[100][i][j][0])\n",
    "    s = \"{:3d}\".format(f)\n",
    "    out += (str(s)+\" \")\n",
    "  print(out)\n",
    "  out = \"\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "M2BPcaKtNgXz"
   },
   "source": [
    "Finally, you will be able to see what the maximum and minimum values of the image are. \n",
    "\n",
    "\n",
    "3. Run the cell below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "id": "GSspChdQNf_T"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 255\n"
     ]
    }
   ],
   "source": [
    "show_min_max(train_images, 100)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "rGaCsk_RNsM8"
   },
   "source": [
    "Now it's time to start your cleaning process. The color in pixels is stored as an integer value between 0 and 255.  While your network can learn from this information, it will be easier if we replace these values with a decimal between 0 and 1.  This keeps the numbers the network is dealing with small.\n",
    "\n",
    "We do this by changing the data to a float32, a kind of decimal number, and then doing some division to get the 0-1 values you want.\n",
    "\n",
    "The cell below shows you how to convert a dataset to float32. \n",
    "\n",
    "\n",
    "4. Add another line to convert the test dataset like the train dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "id": "lpwj1Ai6OBzT"
   },
   "outputs": [],
   "source": [
    "train_images = train_images.astype('float32')\n",
    "# Add the code for test images here:\n",
    "test_images = test_images.astype('float32')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "D5-jx4IsOGQ6"
   },
   "source": [
    "Now you need to divide the images by 255 to ensure that each pixel is stored as a value between 0 and 1.\n",
    "\n",
    "5. Add another line to the cell below to repeat the conversion on the test dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "id": "Ky06LqgyOSX1"
   },
   "outputs": [],
   "source": [
    "train_images /= 255 \n",
    "# Add the code for test images here:\n",
    "test_images /= 255"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "8BaZHoGZOZui"
   },
   "source": [
    "Now look at the same image as before. \n",
    "\n",
    "6. Run the cell below to see what the image looks like visually, what the computer sees, and the min and max of the image now that it's been converted."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "id": "b-hluOMHOmUq"
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAOsAAAD7CAYAAACL3GNOAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/YYfK9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAIXklEQVR4nO3df6zVdR3H8df73huXi1elK1CTyygMIhfadMaS1mo0p7hm02ZLXT82aObcWK1ytpxba6U23TJbVmvhMqf2h2RT+sPbaJUIRROLoKYSYisSrnaHCfcH7/6A2k3P9yP3nMM953XP87GxAe/z/Z7P3XjyuezDOScyUwDaX1erFwDgxBArYIJYARPECpggVsAEsQImiNVcRGyKiE80+7FoP8E5a/uKiJT0b0kp6YikJyV9LzMfaMK9PylpbWa+t/CYDZKukjQ66bdPz8yJRp8fU8fO2v7Ozcx+SW+XtEHSXRFx8zQ+/22Z2T/pB6G2CLGayMwDmfkjSZ+RdGNEnCFJEbE5ItYe/3l3RNweEQciYk9EXB8RGRE9kx8bEe+QdLek90TEoYh4qUVfFqaAWP38VFKPpHfXmK2TdImkd0k6T9KHa90gM3dJulbSluO75dzC810XEcMRsT0irmhg3WgQsZrJzDFJByQN1BhfKembmfl8Zr4o6ZYGn+5OSUslLZB0k6QNEbGqwXuiTsRqJiLeIGm+pOEa4zMl7Zv06301HnPCMvP3mXkwM8cz81FJP5Z0eSP3RP2I1c9lksYlbasx+7ukwUm/XlS4Tz3HACkp6rgOTUCsJiJiICKulvRtSbdm5sEaD3tQ0vqIWBgRcyXdULjlfkmDETGr8JwfiYj+iOiKiIskXSPp4fq/CjSip9ULwOvacfy8dVTSDkmfzcz7Kh77fUnLJD0laUTH/s35fkm1jlt+IWmnpH9ExNHMnFfjMesl/UDHdtM9ktZl5ub6vxQ0gv8UMYNFxCWS7s7Mxa1eCxrHt8EzSET0RcSaiOiJiIWSbpb0UKvXheZgZ51BImKOpF9KWi7pFUmPSFqfmSMtXRiaglgBE3wbDJggVsDElI5uZkVvztYpJ2stQMc7rJc1mkdq/seTKcU6W6doZaxuzqoAvMbWHKqc8W0wYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsBET6sXgAZ1dRfHPW+aX5yPnvXm4vzpq2dNeUn/9atL7yjOB3v6i/Nnxg5Vzi77zheL1y685fHi3BE7K2CCWAETxAqYIFbABLECJogVMMHRTRvonl99vPK3q5YWr80PvFicb7/g3rrW1Ax/GSsfKz02sqA4f/rwisrZok3lr/toceqJnRUwQayACWIFTBArYIJYARPECpggVsAE56xtYPdNSypnf77iW9O4ktfaNTZWObvn4IXFa7d/+fzivHfTb+ta0zG7GrjWEzsrYIJYARPECpggVsAEsQImiBUwQayACc5Zp8Ge+88pzp9YVXrLztnFa/919HBx/r7vfqE4P+NPE8V53/4jlbP4zZPFa3vVyDkqXo2dFTBBrIAJYgVMECtgglgBE8QKmCBWwATnrNPg42dvK87f2FU+Sy354+ipxfmir868jz7sVOysgAliBUwQK2CCWAETxAqYIFbABLECJjhnnQb37r6gOL9h1c667732oU8X52fpibrvjfbCzgqYIFbABLECJogVMEGsgAliBUxwdDMN+jaXX8amVdWjI1n9kYuSNDhUfitRzBzsrIAJYgVMECtgglgBE8QKmCBWwASxAiY4Z21zh7N8jtq7iY9V7BTsrIAJYgVMECtgglgBE8QKmCBWwASxAiaIFTBBrIAJYgVMECtgglgBE8QKmCBWwASxAiaIFTBBrIAJYgVMECtgglgBE8QKmCBWwASxAiZ43+BpcObPnivOt3y+u3J27qzy36dd5ywvzo8+tbs4hw92VsAEsQImiBUwQayACWIFTBArYIKjm2kwvu/54vyliTmVszlR/sjHGzfeX5zveGVxcf567nxkTeVs6e3PFK+d2P/Php4b/4+dFTBBrIAJYgVMECtgglgBE8QKmCBWwERk5gk/+LQYyJWx+iQupzMd+vmSytnmFT+ZxpVMzaf2lv8sPHfbsuK8b+O2Zi5nRtiaQxrJ4ag1Y2cFTBArYIJYARPECpggVsAEsQImiBUwwetZ20D/mr2Vs3d+5fritQM7y+fkL5xX88juf9Zd/Fhx/rmB6rcy/eHioeK1yy5dWp5vLI7xKuysgAliBUwQK2CCWAETxAqYIFbABLECJng9a4frWfKW4vyjj/66cvaxU/cXr/3agRXF+Zbzq98vWZJyfLw4n4l4PSswAxArYIJYARPECpggVsAEsQImeIlchxt/9q/F+a33XFk5u/i6bxSv/dK8PxTnH+q+sDhXBx7dlLCzAiaIFTBBrIAJYgVMECtgglgBE8QKmOCcFUWDX3+8cvbANWcXr7127rPNXk5HY2cFTBArYIJYARPECpggVsAEsQImiBUwwTkrirrf9tbK2ZLe6o+DRPOxswImiBUwQayACWIFTBArYIJYARPECpjgnBVFu9cvqJxd1Pdy8do7hpeXbz4xUc+SOhY7K2CCWAETxAqYIFbABLECJogVMEGsgAnOWVE073eFv88vL1/74F0fLN97fEsdK+pc7KyACWIFTBArYIJYARPECpggVsBEZOYJP/i0GMiVsfokLgfobFtzSCM5HLVm7KyACWIFTBArYIJYARPECpggVsAEsQImiBUwQayACWIFTBArYIJYARPECpggVsAEsQImpvR61oh4QdLek7ccoOMtzsz5tQZTihVA6/BtMGCCWAETxAqYIFbABLECJogVMEGsgAliBUwQK2DiP4IcdWCMsGcwAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.1 0.2 0.5 0.5 1.0 1.0 0.9 0.4 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.1 0.4 0.6 1.0 1.0 1.0 1.0 0.9 0.9 0.8 0.1 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.5 1.0 1.0 1.0 1.0 0.9 0.8 0.2 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.6 1.0 1.0 1.0 0.4 0.3 0.2 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.8 1.0 1.0 0.9 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.6 1.0 1.0 0.5 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.3 1.0 1.0 0.2 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.3 1.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.3 1.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.3 1.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.1 0.9 1.0 0.1 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.9 1.0 0.9 0.8 0.8 0.5 0.1 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.7 1.0 1.0 1.0 1.0 1.0 0.7 0.2 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.5 0.3 0.5 0.8 1.0 1.0 0.6 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.1 0.9 1.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.4 1.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.8 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.1 0.9 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.5 1.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.3 1.0 0.3 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \n",
      "The min and max are: \n",
      "0.0 1.0\n"
     ]
    }
   ],
   "source": [
    "plot_image(train_images, 100, train_labels)\n",
    "\n",
    "out = \"\"\n",
    "for i in range(28):\n",
    "  for j in range(28):\n",
    "    f = (train_images[100][i][j][0])\n",
    "    s = \"{:0.1f}\".format(f)\n",
    "    out += (str(s)+\" \")\n",
    "  print(out)\n",
    "  out = \"\"\n",
    "\n",
    "print(\"The min and max are: \")\n",
    "show_min_max(train_images, 100)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "zVFjbxvqQR9Y"
   },
   "source": [
    "## One-Hot Encoding\n",
    "\n",
    "MNIST is a set of hand-drawn images of the numbers 0-9. The label for each image is then simply the number 0-9.\n",
    "\n",
    "However, there is a problem with this.  Due to how neural networks function, they intuitively believe that the image labeled \"1\" is more similar to the image labeled \"0\" or \"2\" than the image labeled \"7\".  However, that's not the case.  If you write a 0, 1, 2, and 7 on a sheet of paper, the 1 and 7 are more similar in structure, with a long straight line compared with the curves in 0 or 2.\n",
    "\n",
    "![Screenshot from 2022-02-28 11-05-41.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAHcCAYAAAC3eP8LAAAABHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAZ25vbWUtc2NyZWVuc2hvdO8Dvz4AAAAtdEVYdENyZWF0aW9uIFRpbWUATW9uIDI4IEZlYiAyMDIyIDExOjA1OjQ4IEFNIFBTVHMggKgAACAASURBVHic7d13fGV1nf/x17k15aaXSZ1Mn2FgYCgKAoqo2FbEglhBrGtn7bvr2l17w1Wx/cS6YkPEFRVEVhCBgeklk94nyUwyyUx6uff7+2OQFRm+35Sbk5zJ+/l4+HiAObn3cG7OeZ/7PZ/v5+sZYwwiIiIBE1rsHRAREZkLBZiIiASSAkxERAJJASYiIoGkABMRkUBSgImISCApwEREJJAUYCIiEkgKMBERCSQFmIiIBJICTEREAkkBJiIigaQAExGRQFKAiYhIICnAREQkkBRgIiISSAowEREJJAWYiIgEkgJMREQCSQEmIiKBpAATEZFAUoCJiEggKcBERCSQFGAiIhJICjAREQkkBZiIiASSAkxERAJJASYiIoGkABMRkUBSgImISCApwEREJJAUYCIiEkgKMBERCSQFmIiIBJICTEREAkkBJiIigaQAExGRQFKAiYhIICnAREQkkBRgIiISSAowEREJJAWYiIgEkgJMREQCSQEmIiKBpAATEZFAUoCJiEggKcBERCSQFGAiIhJICjAREQkkBZiIiASSAkxERAJJASYiIoGkABMRkUBSgImISCApwEREJJAUYCIiEkgKMBERCSQFmIiIBJICTEREAkkBJiIigaQAExGRQFKAiYhIICnAREQkkBRgIiISSAowEREJJAWYiIgEkgJMREQCSQEmIiKBpAATEZFAUoCJiEggKcBERCSQFGAiIhJICjAREQkkBZiIiASSAkxERAJJASYiIoGkABMRkUBSgImISCApwEREJJAUYCIiEkgKMBERCSQFmIiIBJICTEREAkkBJiIigaQAExGRQFKAiYhIICnAREQkkBRgIiISSAowEREJpMhi74DMnzHm4X8APA/PW9TdERHxhQIs0JK03/VdvvbtX3DXjhb6JwvY8txX8KZ3vI5nb0gs9s6JzIPBGMPkyAgTyRRmsXdnhrxwhPCjbiBHOTbdRX/qKGN45GdsoSpeSFZIg1/p4JlHbt8lWFL0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)\n",
    "\n",
    "One-Hot Encoding is a technique that helps solve this problem by replacing the label on each image with a representation that the network won't think is ordered, so it will view each number independently.\n",
    "\n",
    "1. Add code to repeat the changes to the test data.\n",
    "2. Run the cell."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "id": "e0Z6_Q8_Qmz6"
   },
   "outputs": [],
   "source": [
    "train_labels = keras.utils.to_categorical(train_labels, num_classes) \n",
    "# Add the code for test images here:\n",
    "test_labels = keras.utils.to_categorical(test_labels, num_classes)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "D0iVp1GpQvYw"
   },
   "source": [
    "# Building the Network\n",
    "**Neural networks** learn to accomplish their tasks by reading training data and adjusting their neuron weights to improve their chance of choosing the correct answer.\n",
    "\n",
    "The first kind of network you will create is a densely connected network. In this network, layers of neurons are connected to each other. The output from one layer becomes the input for the next one. These layers manipulate and reshape the data so that the computer can make a guess as to what the output should be.\n",
    "\n",
    "You are going to use a framework called TensorFlow to build, compile and run your first neural network that will be able to detect handwritten digits. \n",
    "\n",
    "1. Run the cell below to import the libraries you need for this network"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "76IEOJjCSF2g"
   },
   "outputs": [],
   "source": [
    "from tensorflow.keras.models import Sequential \n",
    "from tensorflow.keras.layers import Dense, Flatten"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "mxLS4M53SO5H"
   },
   "source": [
    "## Epochs\n",
    "\n",
    "Training is done in a sequence of rounds called epochs. Each epoch is one pass over the dataset.  Meaning, in each epoch, every image in the dataset is passed through your model once.  Generally, the more epochs you run, the better your results, but the longer it will take to train.  Finding the sweet spot between good results and reasonable runtime is a big challenge in training a model.\n",
    "\n",
    "For this first network you will be doing 10 epocjs, but this number can be adjusted as you test.\n",
    "\n",
    "1. In the cell below, set the variable to 10."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "7MAF9wygSaj3"
   },
   "outputs": [],
   "source": [
    "epochs = "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "L_Gyr9xFScxQ"
   },
   "source": [
    "## Model Type\n",
    "\n",
    "You'll be making a sequential model. Sequential models are split into layers. A layer is one set of neurons that processes the inputs from the previous layer, then passes it along to the next layer.  The first layer reads in the original data, and the final layer produces the network's prediction.\n",
    "\n",
    "Determining how many and what kinds of layers to use, and configuring each individual layer is the meat of building a neural network. You'll do this in the next steps, but first, define your model:\n",
    "\n",
    "1. In the cell below, set your model to `Sequential()`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "tc-VsTzLSldg"
   },
   "outputs": [],
   "source": [
    "model = "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "8C20D2asSpA4"
   },
   "source": [
    "## Add The First Layer\n",
    "\n",
    "The first layer to add to this network is a flatten layer. This will take your prepared image data and flatten it into a long series of numbers representing pixels (remember when we prepared the data for this?). This allows the network to take in the data from the image and begin to perform calculations with it. This layer is also known as the input layer, as it takes input.\n",
    "\n",
    "This layer needs to know what the input shape is. Luckily, while preparing the data, we saved the input shape to a variable, so we can use that. \n",
    "\n",
    "1. Add the input shape to the layer being added in the cell below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "1mQGhK78Ts1Q"
   },
   "outputs": [],
   "source": [
    "model.add(Flatten(input_shape= )) \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "_ZlSVRGvTv1p"
   },
   "source": [
    "## Adding the Calculation Layers\n",
    "\n",
    "Next, we need to add a layer to perform predictions on the data. There are a lot of different configurations for this middle part, and a lot of machine learning research is about how to best set these layers up.\n",
    "\n",
    "For right now, you are going to add just one, with `16` neurons. You will also need to decide on an activation algorithm. For this you are going to use the `'relu'` activiation function as it is the best for this problem. \n",
    "\n",
    "1. In the cell below, fill out the amout of nuerons and the activation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "kyoxsO_oUBJH"
   },
   "outputs": [],
   "source": [
    "model.add(Dense(units= , activation= )) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "7KrVLYMDUEvq"
   },
   "source": [
    "## Output Layers\n",
    "\n",
    "The final stage of the network is the output layer. It needs to shrink the previous layer down to just the number of possible classes.  Then, each output of this final layer represents the network's guess on how likely the input is to be from that class.\n",
    "\n",
    "Note that this means that the network produces multiple results for each image, one for each class.  The final decision of the model is the class with the highest weight, determined during training and testing.\n",
    "\n",
    "Since this data has digits from 0-9, there are ten possible answers. You have this information saved from when you were preparing data!\n",
    "\n",
    "1. In the cell below, fill out the number of units needed in this final output layer. It should be the number of classes.\n",
    "2. Fill out the activation function. For your purpose, `softmax` is a good function. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "ssSLnmIvUI1B"
   },
   "outputs": [],
   "source": [
    "model.add(Dense(units=, activation=))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "VcrXqBywUb8_"
   },
   "source": [
    "3. Finally, run the cell below to see what your network looks like."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "zuGbitNBUgQv"
   },
   "outputs": [],
   "source": [
    "model.summary() "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "YX852flSUlEv"
   },
   "source": [
    "As you can see from the output, you have a sequential model, with three layers that reshape the data. There are already 12,730 parameters to train. This means that the network is going to adjust 12,730 numbers each time it runs an epoch. Hopefully, this will be enough to correctly identify the number in the image. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Rgv92aGOUyZn"
   },
   "source": [
    "# Compiling and Training the Network\n",
    "\n",
    "Now, it is time to compile the network. Tensorflow has a command that will do a lot of the work for you, but you still need to set up a few arguments so that this network is compiled in a way that is useful to you.\n",
    "\n",
    "You are going to add this line to compile your network and then read below to learn more about what each argument represents.  \n",
    "\n",
    "After adding the code below, your network will be able to output a decision on what class an image belongs to."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "bjJPPrUsU_JP"
   },
   "source": [
    "\n",
    "<details>\n",
    "<summary>EXPAND + Optimizer: 'adam'</summary>\n",
    "\n",
    "As the name implies, optimization algorithms work by optimizing some value.  Note that optimizing a value can either mean making it as big as possible or as small as possible. For the neural network, the goal is to optimize the loss by making it as small as possible.\n",
    "\n",
    "The optimizer is the mathematics behind this process. This function decides how the network will calculate what the best fit is. There are a lot of different functions to use, each of which has its pros and cons. \n",
    "\n",
    "A popular one for image recognition is **adam** because it is fast and multipurpose.\n",
    "</details>\n",
    "\n",
    "<details>\n",
    "<summary>EXPAND + Loss: 'categorical_crossentropy'</summary>\n",
    "\n",
    "The loss is defined as the difference between the model's prediction and the actual label.  There are a lot of different mathematic methods to calculate this, and choosing the correct method is important. It can change depending on what the output of your network should look like. \n",
    "</details>\n",
    "<details>\n",
    "<summary>EXPAND + Metrics: 'accuracy'</summary>\n",
    "\n",
    "For convenience, the **compile** function allows the programmer to list several metrics to be displayed during training.\n",
    "\n",
    "Accuracy is one such metric. It measures what percentage of the input images the model correctly predicted.  While this is similar to loss, the two are computed differently behind the scenes, so they won't be inverses of each other.</details>\n",
    "\n",
    "\n",
    "1. Using the information above, fill out each part of the compile function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "YksrzOYBU4zW"
   },
   "outputs": [],
   "source": [
    "model.compile(optimizer=, loss=, metrics=[])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "sDMmwIOrWfZO"
   },
   "source": [
    "## Training\n",
    "\n",
    "Now that you have a compiled model, you can fit that model to the actual data that you prepared. The fit stage will use the training data to train the model to recognize numbers.\n",
    "\n",
    "The train_images data set will be the input, the train_labels will keep track of if the network guess is correct or not, and the epochs will be equal to the variable you set up earlier. \n",
    "\n",
    "1. Run the cell below to start training your network."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "IDPasmNOWlBz"
   },
   "outputs": [],
   "source": [
    "model.fit(train_images, train_labels, epochs=epochs, shuffle=True) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "BT5cnpJIWuEW"
   },
   "source": [
    "## Analyzing the Output\n",
    "\n",
    "Your output should look something like the output above! For each epoch, you can see the loss and the accuracy of the network on the training data. As you can see, the accuracy goes up with each epoch, and the loss goes down. \n",
    "\n",
    "Knowing how well the model did on the training data isn't very useful.  It doesn't mean much if you can get an A on a test where you're given the answers.\n",
    "\n",
    "The real test of a model is how well it does on data it hasn't seen before and doesn't know the labels for.  That's exactly what the model.evaluate function is for.\n",
    "\n",
    "This function takes the trained model and the test data and produces a set of scores, or metrics, that show how well the model did on this test data.\n",
    "\n",
    "While model.evaluate takes the test labels as input, they're never shown to the neural network, only used to compare the network's answer to the real answer.\n",
    "\n",
    "After evaluation, the final point of this function is to return the model object for use later as needed. \n",
    "\n",
    "The code below tests the network on the test dataset to see how it does on data it hasn't seen before. \n",
    "\n",
    "1. Add a print statement to see what the test accuracy is. \n",
    "2. Run the cell."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "vfEaxbonW_4t"
   },
   "outputs": [],
   "source": [
    "test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2)\n",
    "# Add a print statement for the test accuracy\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "0SFsxJ5DXbK9"
   },
   "source": [
    "The test accuracy above will tell you how well the network did on data it hasn't seen before. Now you can see how successful your network is! "
   ]
  },
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [],
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
